/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Fastimer
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  regularFastLength: 16
};
var Fastimer = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new FastimerSettingTab(this.app, this));
    this.addCommand({
      id: "insert-fasting-tracker",
      name: "Insert fasting tracker",
      editorCallback: (editor, view) => {
        let startDate = this.timestampToString(this.now());
        editor.replaceSelection("```fastimer\n" + startDate + "\n```");
      }
    });
    this.registerMarkdownCodeBlockProcessor("fastimer", async (src, el, ctx) => {
      let fast = null;
      try {
        fast = this.fast(src, ctx);
      } catch (error) {
        el.createEl("h3", { text: `Failed to read fast: ${error.message}` });
        return;
      }
      try {
        const root = el.createEl("div");
        const body = root.createEl("div");
        await this.renderFast(fast, body, ctx);
      } catch (error) {
        el.createEl("h3", { text: `Failed to show fast: ${error.message}` });
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  ///////////////////////////////////////////////////////////////////
  // FAST READING
  ///////////////////////////////////////////////////////////////////
  fast(content, ctx) {
    const fast = {
      startTimestamp: 0,
      plannedLength: 0,
      currentLength: 0,
      plannedEndTimestamp: 0,
      currentEndTimestamp: 0,
      status: 1 /* Inactive */
    };
    this.initFastFromContent(fast, content);
    this.fillFastPlannedLength(fast);
    this.fillFastCurrentLength(fast);
    this.fillFastPlannedEndTimestamp(fast);
    this.fillFastStatus(fast);
    return fast;
  }
  initFastFromContent(fast, content) {
    let lines = content.split("\n");
    lines.forEach((line) => {
      line = line.trim();
      if (line.match(/^\d*$/)) {
        let value = parseInt(line);
        if (!isNaN(value) && fast.plannedLength == 0) {
          fast.plannedLength = this.secondsInHours(value);
        }
      } else if (line.match(/^\d{4}-\d{1,2}-\d{1,2} \d{1,2}:\d{1,2}$/)) {
        let value = Date.parse(line);
        if (!isNaN(value)) {
          value = value / 1e3;
          if (fast.startTimestamp == 0) {
            fast.startTimestamp = value;
          } else if (fast.currentEndTimestamp == 0) {
            fast.currentEndTimestamp = value;
          }
        }
      }
    });
  }
  fillFastPlannedLength(fast) {
    if (fast.plannedLength == 0) {
      fast.plannedLength = this.settings.regularFastLength;
      if (fast.plannedLength == 0) {
        fast.plannedLength = DEFAULT_SETTINGS.regularFastLength;
      }
      fast.plannedLength = this.secondsInHours(fast.plannedLength);
    }
  }
  fillFastCurrentLength(fast) {
    let finished = fast.currentEndTimestamp == 0 ? Date.now() / 1e3 : fast.currentEndTimestamp;
    fast.currentLength = finished - fast.startTimestamp;
  }
  fillFastPlannedEndTimestamp(fast) {
    fast.plannedEndTimestamp = fast.startTimestamp + fast.plannedLength;
  }
  fillFastStatus(fast) {
    let value = 1 /* Inactive */;
    if (fast.startTimestamp != 0) {
      if (fast.currentEndTimestamp == 0) {
        value = 2 /* Active */;
      } else if (fast.currentLength >= fast.plannedLength) {
        value = 4 /* Completed */;
      } else {
        value = 3 /* Failed */;
      }
    }
    fast.status = value;
  }
  ///////////////////////////////////////////////////////////////////
  // FAST RENDERING
  ///////////////////////////////////////////////////////////////////
  async renderFast(fast, body, ctx) {
    let endTimestamp = fast.currentEndTimestamp > 0 ? fast.currentEndTimestamp : this.now();
    let lines = [];
    this.addLineWithFastTitle(lines, fast);
    if (fast.startTimestamp) {
      lines.push("");
      this.addFastFrom(lines, fast);
      this.addFastGoal(lines, fast);
      lines.push("");
      this.addFastingZones(lines, fast, endTimestamp);
      lines.push("");
      this.addFastProgressBar(lines, fast, endTimestamp);
      lines.push("");
      this.addFastElapsedTime(lines, fast, endTimestamp);
      if (endTimestamp <= fast.plannedEndTimestamp) {
        this.addFastRemainingTime(lines, fast, endTimestamp);
      } else {
        this.addFastExtraTime(lines, fast, endTimestamp);
      }
    }
    body.createEl("pre", { text: lines.join("\n") });
  }
  async addLineWithFastTitle(lines, fast) {
    let text = (/* @__PURE__ */ new Map([
      [1 /* Inactive */, "INACTIVE FAST"],
      [2 /* Active */, "ACTIVE FAST"],
      [4 /* Completed */, "COMPLETED FAST"],
      [3 /* Failed */, "FAILED FAST"]
    ])).get(fast.status);
    if (text === void 0)
      text = "<?>";
    lines.push(text);
  }
  async addFastFrom(lines, fast) {
    let from = this.timestampToString(fast.startTimestamp);
    lines.push(`From: ${from}`);
  }
  async addFastGoal(lines, fast) {
    let goal = this.timestampToString(fast.plannedEndTimestamp);
    lines.push(`Goal: ${goal}`);
  }
  addFastingZones(lines, fast, endTimestamp) {
    let anabolicZoneTimestamp = fast.startTimestamp;
    let catabolicZoneTimestamp = anabolicZoneTimestamp + this.secondsInHours(4);
    let fatBurningZoneTimestamp = catabolicZoneTimestamp + this.secondsInHours(12);
    let ketosisZoneTimestamp = fatBurningZoneTimestamp + this.secondsInHours(8);
    let deepKetosisZoneTimestamp = ketosisZoneTimestamp + this.secondsInHours(48);
    let anabolicZone = {
      startTimestamp: anabolicZoneTimestamp,
      endTimestamp: catabolicZoneTimestamp - 1,
      title: "1. Anabolic    "
    };
    let catabolicZone = {
      startTimestamp: catabolicZoneTimestamp,
      endTimestamp: fatBurningZoneTimestamp - 1,
      title: "2. Catabolic   "
    };
    let fatBurningZone = {
      startTimestamp: fatBurningZoneTimestamp,
      endTimestamp: ketosisZoneTimestamp - 1,
      title: "3. Fat burning "
    };
    let ketosisZone = {
      startTimestamp: ketosisZoneTimestamp,
      endTimestamp: deepKetosisZoneTimestamp - 1,
      title: "4. Ketosis     "
    };
    let deepKetosisZone = {
      startTimestamp: deepKetosisZoneTimestamp,
      endTimestamp: 0,
      title: "5. Deep ketosis"
    };
    lines.push("Fasting zones:");
    lines.push("");
    this.addFastingZone(lines, fast, anabolicZone, endTimestamp);
    this.addFastingZone(lines, fast, catabolicZone, endTimestamp);
    this.addFastingZone(lines, fast, fatBurningZone, endTimestamp);
    this.addFastingZone(lines, fast, ketosisZone, endTimestamp);
    this.addFastingZone(lines, fast, deepKetosisZone, endTimestamp);
  }
  addFastingZone(lines, fast, zone, endTimestamp) {
    let note_text = fast.currentEndTimestamp > 0 ? " \u2190 you were here" : " \u2190 you are here";
    let note = endTimestamp >= zone.startTimestamp && (endTimestamp < zone.endTimestamp || zone.endTimestamp == 0) ? note_text : "";
    let from = this.timestampToString(zone.startTimestamp);
    lines.push(`${zone.title} ${from}${note}`);
  }
  async addFastProgressBar(lines, fast, endTimestamp) {
    let seconds_now = endTimestamp - fast.startTimestamp;
    let seconds_all = fast.plannedEndTimestamp - fast.startTimestamp;
    let percent = seconds_now / seconds_all * 100;
    let done_len = percent / 2.5;
    done_len = done_len < 40 ? done_len : 40;
    let left_len = 40 - done_len;
    let left = "-".repeat(left_len);
    let done = "#".repeat(done_len);
    let tail = Math.floor(percent);
    lines.push(`${done}${left} ${tail}%`);
  }
  addFastElapsedTime(lines, fast, endTimestamp) {
    let timestamp1 = fast.startTimestamp;
    let timestamp2 = fast.currentEndTimestamp == 0 ? endTimestamp : fast.currentEndTimestamp;
    let difference = this.timestampsDifference(timestamp1, timestamp2);
    lines.push(`Elapsed time: ${difference}`);
  }
  addFastRemainingTime(lines, fast, endTimestamp) {
    let difference = this.timestampsDifference(endTimestamp, fast.plannedEndTimestamp);
    lines.push(`Remaining:    ${difference}`);
  }
  addFastExtraTime(lines, fast, endTimestamp) {
    let difference = this.timestampsDifference(fast.plannedEndTimestamp, endTimestamp);
    lines.push(`Extra time:   ${difference}`);
  }
  ///////////////////////////////////////////////////////////////////
  // DATETIME UTILS
  ///////////////////////////////////////////////////////////////////
  now() {
    return Date.now() / 1e3;
  }
  secondsInHours(hours) {
    return hours * 60 * 60;
  }
  timestampToString(ts) {
    let result = new Date(ts * 1e3).toLocaleString(
      "en-CA",
      {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        hour12: false,
        minute: "2-digit"
      }
    );
    return result.replace(",", "");
  }
  timestampsDifference(timestamp1, timestamp2) {
    let seconds = timestamp2 - timestamp1;
    let hours = Math.floor(seconds / 3600);
    let minutes = Math.floor(
      (seconds - hours * 3600) / 60
    );
    return `${hours}h ${minutes}m`;
  }
};
var FastimerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Regular fast length").setDesc("This value is used if the duration is not specified directly.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.regularFastLength.toString()).setValue(this.plugin.settings.regularFastLength.toString()).onChange(async (value) => {
      let parsedValue = parseInt(value);
      if (isNaN(parsedValue)) {
        parsedValue = DEFAULT_SETTINGS.regularFastLength;
      }
      this.plugin.settings.regularFastLength = parsedValue;
      await this.plugin.saveSettings();
    }));
  }
};
